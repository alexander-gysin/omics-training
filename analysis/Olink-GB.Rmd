---
title: "Olink-GB"
author: "alexander-gysin (alexander.gysin@usz.ch)"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: inline
---

# Introduction
This serves as training to analyze Olink data


## Setup {.tabset}

### Directories
```{r Directories}
# Get current file name to make folder
current_file <- "Olink-GB"
#Output paths
output_dir_data <- here::here("output", current_file)
if (!dir.exists(output_dir_data)) dir.create(output_dir_data)

if (!dir.exists(here::here("docs", "figure"))) dir.create(here::here("docs", "figure"))

output_dir_figs <- here::here("docs", "figure", paste0(current_file, ".Rmd"))
if (!dir.exists(output_dir_figs)) dir.create(output_dir_figs)

```

### knitr configuration
```{r knitr config, cache=FALSE}
knitr::opts_chunk$set(warning = FALSE)

knitr::opts_chunk$set(message = FALSE)

knitr::opts_chunk$set(cache = FALSE)

knitr::opts_chunk$set(dev = c("png", "pdf"),
                      dpi = 300, 
                      fig.width = 10,
                      fig.heigt = 8,
                      out.width = "100%",
                      fig.path = paste0(output_dir_figs, "/"),
                      fig.align = "center")
```

### Packages
```{r Packages}
# Utility Packages
library(tidyverse)  # Contains dplyr (data manipulation), readr, tibble (modern df), ggplot2 and more
library(here)       # Uses the project root for file paths; stops "File not found" errors on other PCs
library(magrittr)   # Provides the pipe operator (%>%) to make your code readable
library(RColorBrewer) # Provides professional, color-blind friendly palettes for your plots
library(readxl)     # Used to load excel files

# Differential Expression & PCA Packages
library(limma)            # The gold standard for linear modeling and DEA (works for Olink/Proteomics)
library(stats)            # Built-in R package; provides prcomp() for PCA (no need to load explicitly)
library(FactoMineR)       # Multi Factor Analysis for multi-omics, calculates the contribution to the PCA
library(factoextra)       # PCA Visualization

# Protein Protein interaction
library(rbioapi)          # Allows to access the STRING database via API

# Gene Set Enrichment Analysis
library(msigdbr)          #Allows to download GeneSets
library(clusterProfiler)  #Performs the GSEA provides Statistical correlation, visualization and some flexibility (can handle GO and KEGG)
library(enrichplot)
library(ggridges)

# Visualization Packages
library(EnhancedVolcano)  # Specifically designed for high-quality, easy volcano plots
library(pheatmap)         # Quick and clean heatmaps to visualize clusters after PCA
library(patchwork)        # Essential for combining multiple plots (e.g., PCA next to a Volcano plot)
library(kableExtra)       #better display of tables in the knitted document
```

### ggplot global theme
```{r}
# Set the default ggplot theme globally
theme_set(
  theme_bw(base_size = 12) + 
  theme(
    panel.grid.minor = element_blank(),
    plot.title = element_text(face = "bold", size = 14),
    strip.background = element_rect(fill = "grey95")
  )
)
```

# Data preparation & QC
## Initialization
### Read data
```{r read data}
Olink_data <- read.csv(here::here("data", "quant.csv"), sep = ";")
Clinical_data <- read_excel(here::here("data", "Metadata_Olink_PL.xlsx"))
```

### Define color palette
```{r my_palette}
my_palette <- colorRampPalette(c("navy", "whitesmoke", "firebrick3"))(100)
```

## Data clean-up
### Formating the Olink file
Protein names to rownames in the Olink file
```{r Protein names ro rownames}
Olink_data <- Olink_data %>%
  column_to_rownames("SampleID") # Replace "ProteinID" with your actual column name
```

### Order Olink data according to metadata
```{r Order Olink data}
Olink_data <- Olink_data[, Clinical_data$Barcode]

# Check if column names match metadata barcodes exactly
stopifnot(all(colnames(Olink_data) == Clinical_data$Barcode))
```
### Remove the Olink_ID from the rownames
```{r}
rownames(Olink_data) <- str_remove(rownames(Olink_data), "_.*")
```
### Save Processed Data
```{r}
# These are your core objects for all future analysis
saveRDS(Olink_data, file = file.path(output_dir_data, "Olink_clean.rds"))
saveRDS(Clinical_data, file = file.path(output_dir_data, "Clinical_clean.rds"))
```


### Check for missing values in the Olink file
```{r missing values}
sum(is.na(Olink_data))
```

# Results
## PCA Analysis

### PCA Analysis
```{r PCA Analysis}
# Note: PCA functions usually expect samples in ROWS, so we transpose with t()
pca_res <- PCA(t(Olink_data), graph = FALSE)
```

## PCA visualization 
### Plotting Eigenvalues
```{r eigenvalue vis}
p_scree <- fviz_eig(pca_res, addlabels = TRUE, barfill = "navy", barcolor = "navy")
p_scree
```
**How to interpret this plot:** Each bar represents a Principal Component (PC). The Y-axis shows the percentage of total variance in the protein expression data explained by that specific component.

**What this plot can show you: **A Scree Plot can show you whether your PCA is "captured" by the first few dimensions. If the first two bars are significantly higher than the rest (as they are here at 37.1% cumulative), it confirms that the most important biological patterns are being successfully captured in 2D space.

**Selection criteria:** This plot includes all proteins provided in the filtered Olink_data.

**Interpretation of this plot:** PC1 and PC2 cumulatively explain 37.1% of the variance, which is deemed acceptable.


### Plotting PCA by Group
```{r PCA Plot by group, class.source = "fold-hide"}
# 2. PCA Plot colored by Group
p_pca <- fviz_pca_ind(pca_res,
             label = "none", # Hide sample names for clarity
             habillage = as.factor(Clinical_data$Group), 
             palette = c("indianred", "navy"),
             addEllipses = TRUE, 
             invisible = "quali") +
             theme_minimal() +
             labs(title = "Proteomics PCA")
p_pca
```
> **Key Finding:** The protein profiles of SSc-PAH and SSc-noPAH patients show a visible shift along the primary axes of variance; however, the partial overlap of the 95% confidence ellipses indicates that the groups differ moderately rather than exhibiting entirely distinct proteomic signatures.

* **How to interpret this plot:** Each point represents an individual patient sample. The spatial distance between points reflects the similarity of their overall protein profiles. The shaded "ellipses" represent the **95% confidence intervals** for each group.
* **A PCA Plot can show you:** If the clinical groups naturally "cluster" based on protein expression. Overlapping ellipses suggest high biological variability or a spectrum of disease states, while distinct clusters indicate a strong, group-specific protein signature.
* **Selection Criteria:** This visualization utilizes **all proteins** in the filtered dataset to calculate coordinates and includes all patient samples.

### Visualizing contribution by protein in a simple contribution plot
```{r top 10 proteins, class.source = "fold-hide"}
# manually set a common limit
common_limit <- 0.5
# Visualize the top 10 proteins contributing to PC1
p_top_proteins_PD1 <- fviz_contrib(pca_res, choice = "var", axes = 1, top = 10, fill = "navy", color = "navy", sort.val = "asc") +
  theme_minimal() +
  labs(title = "Top 10 Proteins Contributing to PC1",
       x = "Proteins",
       y = "Contribution [%]")+
  coord_flip(ylim = c(0, common_limit)) # Flips the plot and sets the scale

# Visualize the top 10 proteins contributing to PC2
p_top_proteins_PD2 <- fviz_contrib(pca_res, choice = "var", axes = 2, top = 10, fill = "navy", color = "navy", sort.val = "asc") +
  theme_minimal() +
  labs(title = "Top 10 Proteins Contributing to PC2",
       x = "Proteins",
       y = "Contribution [%]")+
  coord_flip(ylim = c(0, common_limit)) # Flips the plot and sets the scale

# / displays the plots in vertical order
p_top_proteins_PD1 / p_top_proteins_PD2
#alternatively flip the plot horizontally to display more bars 
```
This plot shows the top ten contributing proteins in both PD1 and PD2. The dashed line at 0.1% represents the average contribution which is expected in a Principal Component Analysis featuring aproximately 1000 proteins, anything above is considered a contributor.


### Visualizing contribution by protein in a loading plot
```{r loading plot, class.source = "fold-hide"}
# Variable Correlation Plot
p_loading <- fviz_pca_var(pca_res, 
                          # Only show the top 20 proteins by 'contribution' 
                          # (This keeps the plot clean)
                          select.var = list(contrib = 20), 
                          
                          # Color the proteins by their contribution level
                          col.var = "contrib", 
                          gradient.cols = c("navy", "white", "indianred"),
                          
                          # Avoid text labels overlapping
                          repel = TRUE, 
                          
                          # Visual aesthetics
                          alpha.var = "contrib") + 
  theme_minimal() +
  labs(title = "Loading Plot: Top 20 Proteins",
       subtitle = "Direction shows correlation with PC1 (x) and PC2 (y)")
p_loading
```
How to interpret the Loading Plot:
1.  Horizontal Arrows: These proteins are purely PC1 drivers. If they point to the right, they are high in whatever Group is on the right of your PCA.
2.  Vertical Arrows: These proteins are driving PC2. They don't differentiate your PC1 groups much, but they show a separate trend (maybe Age or Sex).
3.  Diagonal Arrows: These proteins contribute to both PC1 and PC2.
4.  Clusters: If you see a "fan" of 5 proteins all pointing in the exact same direction, those proteins likely belong to the same biological pathway      (e.g., a group of inflammatory cytokines all rising together).

Interpretatio of this Loading Plot:
1.  Since all proteins "point" in the same direction they are all correlated and likely belong to the same biological process
2.  They have a positive correlation with PC1 and a negative correlation with PC2

## Differential Expression Analysis {.tabset}

### Create the Design Matrix
```{r create design matrix}
# 1. Clean the 'Group' column in your metadata directly
# This replaces hyphens/spaces with dots (e.g., SSc-PAH -> SSc.PAH)
Clinical_data$Group_Clean <- make.names(Clinical_data$Group)

# 2. Re-create the group_factor from the clean column
group_factor <- as.factor(Clinical_data$Group_Clean)

# 3. Build the design matrix
design <- model.matrix(~ 0 + group_factor)

# 4. Rename columns to match the clean levels (SSc.PAH, SSc.noPAH)
colnames(design) <- levels(group_factor)
```

### Define the comparison
```{r define the comparison}
# 5. Define the contrast
# Syntax: makeContrasts(Group1 - Group2, levels = design)
contrast.matrix <- makeContrasts(SSc.PAH - SSc.noPAH, levels = design)
```

### Analysis
```{r differential expression analysis}
# Fit the model
fit <- lmFit(Olink_data, design)
fit2 <- contrasts.fit(fit, contrast.matrix)
fit2 <- eBayes(fit2)

# 1. Get the results from limma
de_results <- topTable(fit2, coef = 1, number = Inf, sort.by = "P") %>%
  rownames_to_column("Protein")

# 2. CREATE THE MISSING COLUMN (The Fix)
de_results <- de_results %>%
  mutate(Significance = case_when(
    adj.P.Val < 0.05 & logFC > 0.5  ~ "Up-regulated",
    adj.P.Val < 0.05 & logFC < -0.5 ~ "Down-regulated",
    TRUE                          ~ "Not Significant"
  ))
```

### Save DEA Results
```{r}
# Save the full results table
write.csv(de_results, file = file.path(output_dir_data, "DE_results_SSc_PAH.csv"), row.names = FALSE)

# Also save as RDS to preserve variable types (like the 'Significance' factor)
saveRDS(de_results, file = file.path(output_dir_data, "DE_results_SSc_PAH.rds"))
```

## Visualization of the Differential Analysis
### Volcanoplot preparation
```{r volcano plot preparation, class.source = "fold-hide"}
# --- 1. DATA PREPARATION ---
# Calculate the exact raw p-value that hits the FDR 0.05 threshold
p_cutoff <- de_results %>% 
  filter(adj.P.Val < 0.05) %>% 
  pull(P.Value) %>% 
  max()

# Create a 'Score' to identify the "top corners" (High FC * High Significance)
# This ensures we label the most extreme points in the top-left and top-right.
de_results <- de_results %>%
  mutate(label_score = abs(logFC) * -log10(P.Value))

# Identify top 10 Up and top 10 Down based on this combined score
top_up <- de_results %>%
  filter(Significance == "Up-regulated") %>%
  slice_max(order_by = label_score, n = 10)

top_down <- de_results %>%
  filter(Significance == "Down-regulated") %>%
  slice_min(order_by = logFC, n = 10) # Using logFC here ensures we stay on the left side

# Re-selecting top_down based on score but ensuring they are actually down-regulated
top_down <- de_results %>%
  filter(Significance == "Down-regulated") %>%
  slice_max(order_by = label_score, n = 10)

top_labels <- bind_rows(top_up, top_down)

```


### Volcano plot
```{r volcano plotting, class.source = "fold-hide"}
# --- 2. THE FINAL PLOT ---
ggplot(de_results, aes(x = logFC, y = -log10(P.Value), color = Significance)) +
  geom_point(alpha = 0.4, size = 1.5) +
  scale_color_manual(values = c("Down-regulated" = "navy", 
                                "Not Significant" = "grey85", 
                                "Up-regulated" = "indianred")) +
  
  # Clean, small text labels
  geom_text_repel(data = top_labels, 
                  aes(label = Protein),
                  size = 2.5,
                  color = "black",
                  box.padding = 0.5,
                  point.padding = 0.2,
                  min.segment.length = 0,
                  segment.size = 0.2,
                  segment.color = "grey30",
                  max.overlaps = Inf) +
  
  theme_minimal() +
  labs(title = "SSc.PAH vs SSc.noPAH: Top Hits",
       subtitle = "Labeled by multiplied Significance and Fold Change",
       x = "Log2 Fold Change",
       y = "-log10(Raw P-value)") +
  
  # Guidelines
  geom_vline(xintercept = c(-0.5, 0.5), linetype = "dotted", color = "grey40") +
  geom_hline(yintercept = -log10(p_cutoff), linetype = "dashed", color = "grey40", alpha = 0.7) +
  
  # Move FDR Label to the far LEFT to avoid crashing with the "Up-regulated" top corner
  annotate("label", 
           x = min(de_results$logFC), 
           y = -log10(p_cutoff), 
           label = "FDR < 0.05", 
           hjust = 0.2,             # Align to the left of the x-coordinate
           vjust = 1.4, 
           size = 2.5, 
           color = "black", 
           fill = "white",        # White background prevents "crashing" with grid lines
           label.size = NA,       # Removes the box border
           fontface = "plain")
```


### Heatmap
```{r heatmap, class.source = "fold-hide"}
# 1. Get the names of the top 30 proteins by significance
top_hits <- de_results %>% 
  slice_min(order_by = adj.P.Val, n = 20) %>% 
  pull(Protein)

# 2. Subset your original data
# Assumes Olink_data has proteins as rows and sample IDs as columns
plot_matrix <- Olink_data[top_hits, ]

# 3. Create annotation for the columns (samples)
annotation_col <- data.frame(Status = Clinical_data$Group)
rownames(annotation_col) <- colnames(Olink_data)

# 4. Plot
pheatmap(plot_matrix, 
         scale = "row",                      # Normalize by protein to see relative changes
         annotation_col = annotation_col, 
         show_colnames = FALSE,
         main = "Top 20 Proteins: SSc-PAH vs SSc-noPAH",
         color = my_palette)
```
This graph shows the 20 proteins with the lowest adjusted p-value (False Discovery Rate).
The color indicates the relative change of that protein.
The dendrogram on the left shows the correlation between proteins, closely branched proteins are likely part of the same biological process.
The dendrogram on the top shows how similar the protein profile of the patients are. Closely branched patients have similar protein signatures.
The height of a branch indicates its "closeness" to the next branch.

### Boxplot
```{r boxplot, class.source = "fold-hide", fig.width=12, fig.height=10, dpi=300}
# --- STEP 0: Selection Logic ---
top_pval <- de_results %>% slice_min(order_by = adj.P.Val, n = 5) %>% pull(Protein)
top_fc   <- de_results %>% slice_max(order_by = abs(logFC), n = 5) %>% pull(Protein)
top_score <- de_results %>% slice_max(order_by = label_score, n = 5) %>% pull(Protein)
protein_list <- unique(c(top_pval, top_fc, top_score))

# --- STEP 1: Create plot_data_long from scratch ---
# This ensures the object exists in the local environment
plot_data_long <- Olink_data[protein_list, ] %>%
  as.data.frame() %>%
  rownames_to_column("Protein") %>%
  # Convert to long format (Barcode matches your Clinical_data column)
  pivot_longer(-Protein, names_to = "Barcode", values_to = "NPX") %>%
  # Merge with clinical metadata
  left_join(Clinical_data, by = "Barcode")

# --- STEP 2: Create the multi-line labels ---
plot_labels <- de_results %>%
  filter(Protein %in% protein_list) %>%
  mutate(Facet_Label = paste0(
    Protein, 
    "\nadj.P: ", formatC(adj.P.Val, format = "e", digits = 2),
    "\nlog2FC: ", round(logFC, 2),
    "\nScore: ", round(label_score, 2)
  )) %>%
  select(Protein, Facet_Label)

# --- STEP 3: Add labels to the data ---
plot_data_long <- plot_data_long %>%
  left_join(plot_labels, by = "Protein")

# --- STEP 4: Generate the Grid ---
ggplot(plot_data_long, aes(x = Group, y = NPX, fill = Group)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.7, color = "black", size = 0.3) +
  geom_jitter(width = 0.2, size = 1, alpha = 0.4, color = "grey20") +
  facet_wrap(~Facet_Label, scales = "free_y", ncol = 4) + 
  theme_bw() +
  scale_fill_manual(values = c("SSc-PAH" = "firebrick3", "SSc-noPAH" = "dodgerblue3")) +
  theme(
    legend.position = "none",
    strip.text = element_text(size = 8, face = "bold", lineheight = 1.1),
    strip.background = element_rect(fill = "grey95"),
    axis.text.x = element_text(angle = 45, hjust = 1, size = 9),
    panel.grid.minor = element_blank()
  ) +
  labs(
    title = "Key Differential Proteins: SSc-PAH vs SSc-noPAH",
    subtitle = "Metrics: Adjusted P-value, Log2 Fold Change, and Combined Score",
    x = NULL, 
    y = "Normalized Protein Expression (NPX)"
  )
```
### Save top labels
```{r}
# Save the list of top hits used for labeling and boxplots
saveRDS(protein_list, file = file.path(output_dir_data, "top_hits_DEA_proteins_list.rds"))
```
### MA Plot
```{r MA plot, class.source = "fold-hide"}
# Average expression (A) vs Log Fold Change (M)
# Use 'AveExpr' from limma results
# 1. Create a subset for labeling: 
# Significant proteins with Average Expression < 0
low_expr_labels <- de_results %>%
  filter(AveExpr < 0 & Significance != "Not Significant")

# 2. Plot
ggplot(de_results, aes(x = AveExpr, y = logFC, color = Significance)) +
  geom_point(alpha = 0.4, size = 1.5) +
  scale_color_manual(values = c("Down-regulated" = "navy", 
                                "Not Significant" = "grey70", 
                                "Up-regulated" = "firebrick3")) +
  
  # Add labels for low expression proteins
  geom_text_repel(data = low_expr_labels,
                  aes(label = Protein),
                  size = 3,
                  color = "black",
                  max.overlaps = 20,
                  box.padding = 0.5,
                  segment.size = 0.2) +
  
  geom_hline(yintercept = 0, linetype = "dashed") +
  # Add a vertical line at the 0 threshold for clarity
  geom_vline(xintercept = 0, linetype = "dotted", color = "grey50") +
  
  theme_minimal() +
  labs(title = "MA Plot: Log Fold Change vs. Average Expression",
       subtitle = "Labels indicate significant proteins with log2 NPX < 0",
       x = "Average Expression (log2 NPX)",
       y = "Log2 Fold Change")
```
**How to interpret a MA-Plot**

1. Technical noise: Points to the far left are more susceptible to technical noise
2. Horizontal Symmetry: The cloud should be roughly centered around y=0 if not this indicates a normalization issue.
3. Biological Significance: Hits on the right are moe robust (higher signal to noise ratio) than the ones on the left.

**Interpretation of this Plot**
Only one hit might be due to technical noise
The cloud is not centered around y=0
The hits are (with one exeption) distributed across the x-axis

## Protein Protein Interaction
```{r map Gene Symbolds to String Protein IDs, class.source="hide-fold"}
# 1. Get your top 30 proteins
top_proteins <- de_results %>%
  slice_min(order_by = adj.P.Val, n = 30) %>%
  pull(Protein) %>%
  as.character()

# 2. Run the function
rba_string_network_image(
  ids = top_proteins, 
  species = 9606, 
  image_format = "highres_image"
)

# 3. Define paths
rbio_dir <- here::here("analysis", "rbioapi")
source_path <- file.path(rbio_dir, "string_network_image.png")
target_path <- file.path(output_dir_figs, "ppi_network.png")

# 4. Move the file and delete the folder
if (file.exists(source_path)) {
  # Ensure target directory exists
  if (!dir.exists(dirname(target_path))) dir.create(dirname(target_path), recursive = TRUE)
  
  # Move and rename
  file.rename(source_path, target_path)
  
  # Delete the rbioapi folder and its remaining contents
  unlink(rbio_dir, recursive = TRUE)
}

# 5. Display the image
if (file.exists(target_path)) {
  knitr::include_graphics(target_path)
}
```
**How to interpret a Protein-Protein-Interaction Network**
Nodes: Each note is a protein
Lines: Represent "interactions" it combines physical and functional interaction. Thicker lines indicate higher confidence.

Hub Proteins:   Proteins which interact with a lot of other proteins are "hubs", they are central to the biological process
Clusters:       Clusters are functional modules
Singletons:     They might represent a biological process that differs from the ones represented by the other proteins or clusters


## Enrichment Analysis
just analyses the 30 top proteins also displayed in the PPI plot
### Fetch STRING Enrichment Results
```{r get_string_enrichment}
# 1. We use the same top 30 proteins used for the PPI network
top_proteins_enrich <- de_results %>%
  slice_min(order_by = adj.P.Val, n = 30) %>%
  pull(Protein) %>%
  as.character()

# 2. Call the STRING API to get functional enrichment
# This creates the 'enrichment_results' object that was missing
enrichment_results <- rba_string_enrichment(
  ids = top_proteins_enrich,
  species = 9606
)
```

```{r Functional Enrichment, class.source="fold-hide"}
# 1. Combine the list of results into a single data frame
# rba_string_enrichment returns a list of tables; bind_rows stacks them
enrichment_all <- enrichment_results %>% bind_rows()

# 2. Filter for specific biological categories
# We use categories confirmed to exist in your data: Function, Component, and Keyword
enrichment_clean <- enrichment_all %>%
  filter(category %in% c("Function", "Component", "Keyword")) %>%
  arrange(fdr) %>% # Sort by significance (lowest False Discovery Rate first)
  
  # Safely select columns: any_of() prevents errors if column names vary across versions
  # It looks for 'count', 'number_of_nodes', or 'number_of_genes'
  select(term, description, fdr, category, 
         any_of(c("count", "number_of_nodes", "number_of_genes"))) %>%
  
  # Rename the 5th column to 'Count' so our plotting code always works
  rename(Count = 5)

# 3. Prepare data for plotting
# We take the top 15 most significant pathways and fix mathematical issues
plot_data <- head(enrichment_clean, 15) %>%
  mutate(
    fdr = as.numeric(fdr),
    # If FDR is 0, replace with a tiny number to allow -log10 calculation (which fails at 0)
    fdr = ifelse(fdr <= 0, 1e-10, fdr), 
    # Calculate the negative log10 of the FDR for better visualization (higher = more significant)
    neg_log10_fdr = -log10(fdr)
  )

# 4. Create the Lollipop Plot
# This is a cleaner alternative to a bar chart for categorical data
ggplot(plot_data, 
       aes(x = reorder(description, neg_log10_fdr), y = neg_log10_fdr)) +
  
  # Draw the "stick" of the lollipop
  geom_segment(aes(xend = reorder(description, neg_log10_fdr), yend = 0), 
               color = "grey50") +
  
  # Draw the "candy" (point) of the lollipop
  # Size of point represents number of proteins; color represents the database source
  geom_point(aes(size = Count, color = category), alpha = 0.8) +
  
  # Flip coordinates to make long pathway descriptions easy to read
  coord_flip() +
  
  # Use a clean, professional theme for the report
  theme_minimal() +
  
  # Apply a distinct color palette for the categories
  scale_color_brewer(palette = "Dark2") + 
  
  # Add descriptive labels for the report
  labs(
    title = "Functional Enrichment: SSc-PAH vs SSc-noPAH",
    subtitle = "Top 15 Molecular Functions & Components",
    x = NULL, # Description is self-explanatory on the Y-axis
    y = "-log10(FDR)",
    size = "Protein Count",
    color = "Category"
  )
```
**How to interpret this plot**
1. Length of the line: A longer line indicates a lower FDR which indicates higher significance
2. Size of the dot: Indicates the protein count
3. Color of the dot: Indicates to which category the dot belongs

### Table of Top 15 Enrichment Groups and Proteins
### Generate a Clean Table of Top 15 Enrichment Groups
```{r enrichment_table_clean, class.source="fold-hide"}
# 1. Take the top 15 groups
top_15_groups <- head(enrichment_clean, 15)

# 2. Join with raw data and format the protein list
enrichment_table_clean <- top_15_groups %>%
  left_join(
    enrichment_all %>% select(description, inputGenes), 
    by = "description"
  ) %>%
  mutate(
    # Remove c(), quotes, and extra spaces
    # This turns c("ACE2", "HGF") into "ACE2, HGF"
    Proteins = gsub('c\\(|\\)|"|\\s', '', inputGenes),
    # Optional: Replace commas with ", " for better line-wrapping in tables
    Proteins = gsub(',', ', ', Proteins),
    # Format FDR to a clean scientific notation
    FDR = formatC(as.numeric(fdr), format = "e", digits = 2)
  ) %>%
  # 3. Select and rename for the final display
  select(
    Category = category,
    Description = description,
    Count = Count,
    FDR,
    `Associated Proteins` = Proteins
  )

# 4. Display with kableExtra for a high-quality look
knitr::kable(enrichment_table_clean, 
             caption = "Table 1: Top 15 Functional Enrichment Terms",
             booktabs = TRUE) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), 
                full_width = F, 
                position = "left") %>%
  column_spec(5, width = "30em") # This prevents the protein list from making the table too wide
```

## Gene Set Enrichment Analysis from the DEA
### Prepare Ranked List for GSEA
```{r gsea_prep, class.source="fold-hide"}
# We need a clean, sorted, named vector with no NAs
gsea_input <- de_results %>%
  # Remove rows where Protein name or t-statistic is missing
  filter(!is.na(Protein), !is.na(t)) %>%
  # If there are duplicate protein names, take the one with the highest absolute t-stat
  group_by(Protein) %>%
  slice_max(order_by = abs(t), n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  # Sort descending by t-statistic
  arrange(desc(t))

# Create the named vector
ranked_vec <- gsea_input$t
names(ranked_vec) <- gsea_input$Protein

# FINAL CHECK: Remove any remaining NAs or non-finite values (like Inf)
ranked_vec <- ranked_vec[is.finite(ranked_vec)]
```

### Run GSEA
```{r run_gsea, class.source="fold-hide"}
### 1. Get GO Biological Process Gene Sets
go_genesets <- msigdbr(species = "Homo sapiens", category = "C5", subcategory = "BP") %>%
  select(gs_name, gene_symbol)

### 2. Run GSEA with GO-BP
gsea_res <- GSEA(
  geneList = ranked_vec,
  TERM2GENE = go_genesets,
  pvalueCutoff = 1,      # See everything first
  minGSSize = 5,         # Suitable for Olink
  maxGSSize = 500,
  eps = 0,               # Better precision for p-values
  nPermSimple = 10000,   # More stable permutations
  verbose = FALSE
)

# Check the results
gsea_results_df <- as.data.frame(gsea_res)
# print(paste("Number of GO terms found:", nrow(gsea_results_df)))
```

### Filter GSEA Results
This filter is too strict.
Instead for searcing for significant differences lets's search for trends and label them as such. remplace FDR with uncorrected p-value
```{r}
# 1. Choose your filter: Trends (pvalue) vs. Significant (p.adjust)
gsea_trends <- gsea_results_df %>%
  # Filter for trends (raw p-value < 0.05)
  filter(pvalue < 0.05) %>% 
  
  # --- UNCOMMENT BELOW TO SWITCH BACK TO STRICT SIGNIFICANCE ---
  # filter(p.adjust < 0.05) %>% 
  # --------------------------------------------------------------
  
  # 2. Separate the NES into 'Activated' and 'Suppressed'
  mutate(Status = ifelse(NES > 0, "Up-regulated in SSc-PAH", "Down-regulated in SSc-PAH")) %>%
  
  # 3. Clean the GO Term names (Remove GOBP_ and underscores)
  mutate(Description = gsub("GOBP_", "", Description),
         Description = gsub("_", " ", Description)) %>%
  
  # 4. Order by effect size (NES)
  arrange(desc(abs(NES)))

# Check how many trending terms remain
print(paste("Trending GO terms (raw p < 0.05) found:", nrow(gsea_trends)))

# Save the trending results for your supplement
write.csv(gsea_trends, file = file.path(output_dir_data, "GSEA_GO_BP_trends.csv"), row.names = FALSE)
```

### Visualization of GSEA
```{r Visualization of GSEA, fig.width=8, fig.height=8}
# 1. Prepare the data with wrapped labels
top_10_trends_wrapped <- gsea_trends %>%
  group_by(Status) %>%
  slice_max(order_by = abs(NES), n = 10) %>%
  ungroup() %>%
  mutate(
    # Wrap strings at 40 characters
    # You can change 40 to 30 if you want them even narrower
    Description_Wrapped = str_wrap(Description, width = 40)
  )

# 2. Create the plot
ggplot(top_10_trends_wrapped, aes(x = NES, y = reorder(Description_Wrapped, NES))) +
  geom_point(aes(size = setSize, color = pvalue)) +
  
  # Standard color scale: red for significant/high-p, blue for low-p (or vice versa)
  scale_color_gradient(low = "indianred3", high = "navyblue") +
  
  # Add a vertical line at 0
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey50") +
  
  theme_minimal() +
  theme(
    # Increase line spacing for the wrapped y-axis labels
    axis.text.y = element_text(lineheight = 0.8, size = 9),
    panel.grid.minor = element_blank()
  ) +
  labs(
    title = "Top Biological Trends in SSc-PAH (GSEA)",
    subtitle = "Top 10 Up/Down pathways (raw p-value < 0.05)",
    x = "Normalized Enrichment Score (NES)",
    y = NULL,
    size = "Protein Count",
    color = "P-value"
  )
```

### Ridge plot of Top GSEA Trends
```{r ridgeplot of GSEA, fig.width=8, fig.height=13}
# 1. Get the names of the pathways you used in your "Trends" plot
# (Assuming you want the top 15 by absolute NES)
target_pathways <- gsea_trends %>%
  arrange(desc(abs(NES))) %>%
  slice_head(n = 20) %>%
  pull(ID) # We use ID because clusterProfiler functions prefer the original GOBP_ ID

# 2. Force the ridgeplot to show ONLY these pathways
ridgeplot(gsea_res, showCategory = target_pathways) +
  theme_minimal() +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red") +
  labs(title = "Distribution of Trends in SSc-PAH",
       x = "Differential Expression Score (t-statistic)",
       y = NULL)
```
**How to interpret this plot**
x-Axis: values higher than 0 indicate enrichment in SSc-PHA, lower than 0 indicates depletion in SSc-PHA
        t-statistic indicates the magintude of the cahnge relative to the change
The width: narrow & tall peak inidcates that all proteins in that group behave similarly, wide flat peak indicates that there is variance within the biological process



